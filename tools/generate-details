#!/usr/bin/perl

# generate-details
#
# Copyright (c) 2010, 2011 Nick Morrott.
# Copyright (c) 2009, 2010 Mattias Holmlund.

# This file is part of MythTV Translation Tool.
#
# MythTV Translation Tool is free software: you can redistribute it and/or 
# modify it under the terms of the GNU General Public License as published 
# by the Free Software Foundation, either version 3 of the License, or 
# (at your option) any later version.
#
# MythTV Translation Tool is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of 
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General 
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along 
# with MythTV Translation Tool.  If not, see <http://www.gnu.org/licenses/>.

use strict;
use warnings;

use Data::Dumper;
use File::Slurp;
use FindBin;
use Template;

if( scalar( @ARGV ) != 5 ) {
  print STDERR << "EOH";

generate-details <lupdate_log> <lrelease_log> <title> <outdir> <revision>

lupdate_log shall be a logfile generated by lupdate
lrelease_log shall be a logfile generated by lrelease
title shall be a title for the log data
outdir shall be where to write the dump file to
revision shall be the current revision of the code

EOH

  exit 1;
}

my( $lupdate_log, $lrelease_log, $title, $outdir, $revision ) = @ARGV;

# some useful options (see below for full list)
my $config = {
    INCLUDE_PATH => "$FindBin::Bin/../templates/",
    INTERPOLATE  => 1,               # expand "$var" in plain text
    POST_CHOMP   => 1,               # cleanup whitespace
#   PRE_PROCESS  => 'header',        # prefix each template
    EVAL_PERL    => 1,               # evaluate Perl code blocks
};

# create Template object
my $template = Template->new($config);

my $summary;    # hashref to store summary information
my $details;    # hashref to store detailed information
my $meta;       # hashref to store meta information
$meta->{revision} = $revision;
$meta->{srctype} = $title;
$meta->{updated} = scalar localtime(time);
$summary->{meta} = $meta;
$details->{meta} = $meta;

# Memory is cheap...
my @lupdate_lines = read_file( $lupdate_log );

LUPDATE_LOG_LINE:
for (my $line = 0; $line <$#lupdate_lines; $line++) {
    next LUPDATE_LOG_LINE if $lupdate_lines[$line] !~ /^Updating/;

    # determine component and language
    $lupdate_lines[$line] =~ /^.*i18n\/(myth[a-z0-9]*)_(.*)\.ts/i;
    my($component, $lang) = ($1, $2);

    # read in next line containing translation stats
    $line++;
    $lupdate_lines[$line] =~ /Found\s(\d+)/i;
    # note that "already existing" value does not differentiate between 
    # finished and unfinished, so we do not capture it here
    my($total) = ($1);

    # store processed results per component
    $details->{by_lang}->{$lang}->{'by_component'}->{$component}->{total} = $total;

    # store overall results for components seen (note some components may
    # have no translations available, and are handled later)
    $details->{by_lang}->{$lang}->{overall}->{total} += $total;

    # store unique component names and their total available translations
    $details->{allcomponents}->{$component}->{total} = $total
            unless exists $details->{allcomponents}->{$component};
}

# Memory is still cheap...
my @lrelease_lines = read_file( $lrelease_log );

LRELEASE_LOG_LINE:
for (my $line = 0; $line <$#lrelease_lines; $line++) {
    next LRELEASE_LOG_LINE if $lrelease_lines[$line] !~ /^Updating/;

    # determine component and language
    $lrelease_lines[$line] =~ /^.*i18n\/(myth[a-z0-9]*)_(.*)\.qm/i;
    my($component, $lang) = ($1, $2);

    # read in next line containing translation stats
    $line++;
    $lrelease_lines[$line] =~ /(\d+)\sfinished/;
    my($completed) = ($1);

    # store processed results per component
    $details->{by_lang}->{$lang}->{'by_component'}->{$component}->{completed} = $completed;
    $details->{by_lang}->{$lang}->{'by_component'}->{$component}->{overall} 
            = (100 * $completed) / $details->{by_lang}->{$lang}->{'by_component'}->{$component}->{total};

    # store overall results for components seen (note some components may
    # have no translations available, and are handled later)
    $details->{by_lang}->{$lang}->{overall}->{completed} += $completed;
}

# Check whether all langs have details for all components; fill in missing
# if required
foreach my $lang (sort keys %{$details->{by_lang}}) {
    foreach my $comp (sort keys %{$details->{allcomponents}}) {
        # update totals for missing components
        unless (exists $details->{by_lang}->{$lang}->{'by_component'}->{$comp}) {
            # update the per-components totals
            $details->{by_lang}->{$lang}->{'by_component'}->{$comp}->{completed} = 0;
            $details->{by_lang}->{$lang}->{'by_component'}->{$comp}->{total} = $details->{allcomponents}->{$comp}->{total};
            $details->{by_lang}->{$lang}->{'by_component'}->{$comp}->{overall} = 0;
            # update the per-language overall total
            $details->{by_lang}->{$lang}->{overall}->{total} += $details->{allcomponents}->{$comp}->{total};
        }
    }
}

# Determine overall stats for all langs and store in summary data
foreach my $lang (sort keys %{$details->{by_lang}}) {
    my $overall_pct = ( 100 * $details->{by_lang}->{$lang}->{overall}->{completed} )
                      / $details->{by_lang}->{$lang}->{overall}->{total};
    $summary->{by_lang}->{$lang} = $overall_pct;
    $details->{by_lang}->{$lang}->{overall}->{overall} = $overall_pct;
}

# write out the summary results
open( OUT, "> $outdir/summary.dump" ) or die "open failed";
$Data::Dumper::Terse = 1;
print OUT Dumper( $summary );
close( OUT );

# process input template, substituting variables
$template->process( 'result', $details, "$outdir/result.html" )
    || die $template->error();

#print Dumper( $details );
#print Dumper( $summary );
